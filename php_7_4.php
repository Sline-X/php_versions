<?php

//Типизированные свойства
//Свойства класса теперь поддерживают объявления типов.
class User {
    public int $id;
    public string $name;
}

//Стрелочные функции
//Стрелочные функции - это сокращённая запись для определения функций с неявной привязкой 
//родительской области видимости по значению.
$factor = 10;
$nums = array_map(fn($n) => $n * $factor, [1, 2, 3, 4]);
// $nums = array(10, 20, 30, 40);

$y = 1;

$fn1 = fn($x) => $x + $y;
// эквивалентно использованию $y по значению:
$fn2 = function ($x) use ($y) {
    return $x + $y;
};

var_export($fn1(3));

$z = 1;
$fn = fn($x) => fn($y) => $x * $y + $z;
// Выведет 51
var_export($fn(5)(10));
//Подобно анонимным функциям, синтаксис стрелочных функций допускает произвольные сигнатуры функций, 
//включая типы параметров и возвращаемых значений, значения по умолчанию, переменные, а также 
//передачу и возврат по ссылке. Ниже приведены корректные примеры стрелочных функций:
fn(array $x) => $x;
static fn(): int => $x;
fn($x = 42) => $x;
fn(&$x) => $x;
fn&($x) => $x;
fn($x, ...$rest) => $rest;
//Стрелочные функции используют привязку переменных по значению. Это примерно эквивалентно 
//выполнению use($x) для каждой переменной $x, используемой внутри стрелочной функции. Привязка 
//по значению означает, что невозможно изменить какие-либо значения из внешней области. Вместо этого 
//можно использовать анонимные функции для привязок по ссылкам.
$x = 1;
$fn = fn() => $x++; // Ничего не изменит
$fn();
var_export($x);  // Выведет 1


//Ограниченная ковариация возвращаемого типа и контравариантность типа аргумента
class A {}
class B extends A {}

class Producer {
    public function method(): A {}
}
class ChildProducer extends Producer {
    public function method(): B {}
}
//Полная поддержка вариантности доступна только при использовании автозагрузки. 
//Внутри одного файла могут быть только нециклические ссылки, поскольку все классы должны быть 
//определены, перед тем как на них ссылаться.

//Присваивающий оператор объединения с null
$array['key'] ??= computeDefault();
// примерно то же самое
if (!isset($array['key'])) {
    $array['key'] = computeDefault();
}

//Распаковка внутри массивов
$parts = ['apple', 'pear'];
$fruits = ['banana', 'orange', ...$parts, 'watermelon'];
// ['banana', 'orange', 'apple', 'pear', 'watermelon'];


//Пользовательская сериализация объектов
//Добавлен новый механизм сериализации пользовательских объектов, использующий два новых 
//магических метода: __serialize и __unserialize.

// Возвращает массив, содержащий все необходимое состояние объекта.
//public function __serialize(): array;

// Восстанавливает состояние объекта из указанного массива данных.
//public function __unserialize(array $data): void;